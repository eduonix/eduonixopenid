package eduonix.server.security;

import org.apache.log4j.Logger;

import org.socraticgrid.shared.util.PortalConstant;

import javax.servlet.*;

import javax.servlet.http.HttpServletRequest;

import javax.servlet.http.HttpServletResponse;

import javax.servlet.http.HttpSession;

import java.io.IOException;

import java.util.Date;

/**

 * Licensed to the Apache Software Foundation (ASF) under one

 * or more contributor license agreements. See the NOTICE file

 * distributed with this work for additional information

 * regarding copyright ownership. The ASF licenses this file

 * to you under the Apache License, Version 2.0 (the

 * "License"); you may not use this file except in compliance

 * with the License. You may obtain a copy of the License at

 * <p/>

 * http://www.apache.org/licenses/LICENSEÂ­2.0

 * <p/>

 * Unless required by applicable law or agreed to in writing,

 * software distributed under the License is distributed on an

 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY

 * KIND, either express or implied. See the License for the

 * specific language governing permissions and limitations

 * under the License.

 */

/**

 * A filter to secure the client GWT rpc calls. Will return a 401 http status code

 * for illegal access.

 */

public class Authentication401Filter extends AbstractOauthRequestFilter implements Filter {

    private static Logger log = Logger.getLogger(Authentication401Filter.class);

    /**

     * This method checks if the request is a rpc call, if not request continues, if request is

     * an rpc call it checks if there is a access token in the session. If no access token in

     * the session it returns a 401 for the request. If there is a access token then request continues.

     *

     * @param servletRequest standard java filter servletRequest instance

     * @param servletResponse standard java filter servletResponse instance

     * @param filterChain standard java filter config filterChain

     * @throws IOException

     * @throws ServletException

     */

    @Override

    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain

            filterChain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) servletRequest;

        HttpServletResponse response = (HttpServletResponse) servletResponse;

        HttpSession session = request.getSession();

//Get the IP address of client machine.

        String ipAddress = request.getRemoteAddr();

//Log the IP address and current timestamp.

        log.info("Authentication401Filter Filtering request from IP " + ipAddress + ", at Time " + new

                Date().toString());

        log.info("Authentication401Filter Filtering request from Method " + request.getRequestURI());

        if (request.getRequestURI().startsWith("/images")) {

            log.info("Authentication401Filter Skip images");

            filterChain.doFilter(request, response);

        }

        if (request.getRequestURI().startsWith("/css")) {

            log.info("Authentication401Filter Skip css");

            filterChain.doFilter(request, response);

        }

        if (request.getRequestURI().startsWith("/js")) {

            log.info("Authentication401Filter Skip js");

            filterChain.doFilter(request, response);

        }

        log.info("Authentication401Filter Filtering request from Method " + request.getMethod());

        String tokenExists = (String)

                session.getAttribute(PortalConstant.SessionVariable.ACCESS_TOKEN.name());

        log.info("Authentication401Filter Filtering request and tokenExists = " + tokenExists);

        if (tokenExists == null) {

            log.warn("Authentication401Filter Filtering request and tokenExists == null return 404 ");

            response.sendError(HttpServletResponse.SC_UNAUTHORIZED);

            return;

        }

        filterChain.doFilter(servletRequest, servletResponse);

    }

    @Override

    public void destroy() {

    }

}